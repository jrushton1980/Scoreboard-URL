<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Scoreboard Overlay</title>
<style>
  body { background: transparent; color: white; font-family: Arial, sans-serif; }
  .row { display:flex; justify-content:space-between; width:100%; max-width:900px; margin:10px auto; }
  .team { font-size:28px; font-weight:bold; }
  .score { font-size:48px; }
  #clock { font-size:36px; }
</style>
</head>
<body>
  <div class="row">
    <div class="team" id="tA">Team A</div>
    <div class="score" id="sA">0</div>
    <div id="clock">20:00</div>
    <div class="score" id="sB">0</div>
    <div class="team" id="tB">Team B</div>
  </div>

<script>
const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbzch9SYxZbzoGwZm3rlgzDPmZes1mjFD0GWJrzTzuF-ndvH51lLW7HGTOZXfh0NdY_K/exec"; // replace

let overlayState = {
  teamAName:'', teamBName:'', teamAScore:0, teamBScore:0,
  teamAShots:0, teamBShots:0, Period:1, TimerSeconds:1200, Running:false
};
let overlayTimerInterval = null;
let lastFetch = 0;

function formatTime(sec){
  const m=Math.floor(sec/60), s=sec%60;
  return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
}

function applyState(data){
  // Update non-timer fields
  if(data.teamAName !== undefined) document.getElementById('tA').textContent = data.teamAName;
  if(data.teamBName !== undefined) document.getElementById('tB').textContent = data.teamBName;
  if(data.teamAScore !== undefined) document.getElementById('sA').textContent = data.teamAScore;
  if(data.teamBScore !== undefined) document.getElementById('sB').textContent = data.teamBScore;

  // Timer/resync logic:
  // If Running changed -> start/stop accordingly.
  // If TimerSeconds differs substantially (>1s) from local -> resync to authoritative value.
  const remoteRunning = !!data.Running;
  const remoteTimer = Number(data.TimerSeconds) || 0;

  // If we don't have a local interval, set the local time to remote
  if(overlayTimerInterval === null){
    overlayState.TimerSeconds = remoteTimer;
    overlayState.Running = remoteRunning;
    document.getElementById('clock').textContent = formatTime(overlayState.TimerSeconds);
    if(overlayState.Running) startOverlayTimer();
  } else {
    // If remote Running changed, reflect that
    if(remoteRunning !== overlayState.Running){
      overlayState.Running = remoteRunning;
      if(remoteRunning) startOverlayTimer(); else stopOverlayTimer();
    }
    // If remote timer drifts significantly (>=2s) or remote just changed (e.g. setClock), resync
    if(Math.abs(remoteTimer - overlayState.TimerSeconds) >= 2){
      overlayState.TimerSeconds = remoteTimer;
      document.getElementById('clock').textContent = formatTime(overlayState.TimerSeconds);
    }
  }
}

function startOverlayTimer(){
  if(overlayTimerInterval) clearInterval(overlayTimerInterval);
  overlayTimerInterval = setInterval(()=>{
    if(overlayState.TimerSeconds > 0 && overlayState.Running){
      overlayState.TimerSeconds--;
      document.getElementById('clock').textContent = formatTime(overlayState.TimerSeconds);
    }
  },1000);
}

function stopOverlayTimer(){
  if(overlayTimerInterval) clearInterval(overlayTimerInterval);
  overlayTimerInterval = null;
}

async function fetchState(){
  try {
    const now = Date.now();
    // simple throttle: allow up to 1/sec
    if(now - lastFetch < 900) return;
    lastFetch = now;
    const res = await fetch(SCRIPT_URL);
    const data = await res.json();
    // update overlayState basics (scores/names)
    overlayState.teamAName = data.teamAName;
    overlayState.teamBName = data.teamBName;
    overlayState.teamAScore = Number(data.teamAScore)||0;
    overlayState.teamBScore = Number(data.teamBScore)||0;
    overlayState.Running = !!data.Running;
    // apply visual changes (and resync timer if needed)
    applyState(data);
  } catch(e){
    console.error('fetchState', e);
  }
}

// poll every 1s
setInterval(fetchState, 1000);
fetchState();
</script>
</body>
</html>
